use std::{
	io,
	pin::Pin,
	task::{Context, Poll, Waker},
	time::Duration,
};

use futures::{
	AsyncRead, AsyncWrite, FutureExt, StreamExt,
	stream::{self, FuturesUnordered},
};
use futures_timer::Delay;
use multiaddr::Multiaddr;
use rs_mojave_network_core::muxing::{StreamMuxerBox, StreamMuxerEvent, StreamMuxerExt};

mod connection_id;
pub mod negotiator;

use crate::{
	ConnectionEvent, ProtocolHandler,
	connection::negotiator::{InboundStream, OutboundStream, StreamProtocols},
};

pub trait AsyncReadWrite: AsyncRead + AsyncWrite {}
impl<T: AsyncRead + AsyncWrite + ?Sized> AsyncReadWrite for T {}

pub use connection_id::*;

pub struct Connection<THandler> {
	handler: THandler,

	protocols: StreamProtocols,

	muxer: StreamMuxerBox,

	futures_substream: FuturesUnordered<FutureSubstream>,

	negotiating_in: FuturesUnordered<InboundStream<Box<dyn AsyncReadWrite + Send + Unpin>>>,

	negotiating_out: FuturesUnordered<OutboundStream<Box<dyn AsyncReadWrite + Send + Unpin>>>,
}

enum FutureSubstream {
	Waiting { timeout: Delay, warker: Option<Waker> },
	Done,
}

impl FutureSubstream {
	pub fn new(timeout: Duration) -> Self {
		FutureSubstream::Waiting {
			timeout: Delay::new(timeout),
			warker: None,
		}
	}

	pub fn done(&mut self) {
		match std::mem::replace(self, Self::Done) {
			FutureSubstream::Waiting { warker, .. } => {
				if let Some(warker) = warker {
					warker.wake();
				}
			}
			FutureSubstream::Done => panic!("FutureSubstream::done() called twice"),
		}
	}
}

impl Unpin for FutureSubstream {}

impl Future for FutureSubstream {
	type Output = Result<(), ()>;

	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
		let this = self.get_mut();
		match std::mem::replace(this, Self::Done) {
			FutureSubstream::Waiting { mut timeout, .. } => match timeout.poll_unpin(cx) {
				Poll::Ready(_) => {
					*this = FutureSubstream::Done;
					Poll::Ready(Err(()))
				}
				Poll::Pending => {
					*this = FutureSubstream::Waiting {
						timeout,
						warker: Some(cx.waker().clone()),
					};
					Poll::Pending
				}
			},
			FutureSubstream::Done => Poll::Ready(Ok(())),
		}
	}
}

/// Event generated by a [`Connection`].
#[derive(Debug, Clone)]
pub(crate) enum Event<T> {
	/// Event generated by the [`ConnectionHandler`].
	Handler(T),
	/// Address of the remote has changed.
	AddressChange(Multiaddr),
}

/// Errors that can occur in the context of an established `Connection`.
#[derive(Debug, thiserror::Error)]
pub enum ConnectionError {
	#[error(transparent)]
	MuxerError(#[from] io::Error),

	#[error(transparent)]
	TransportError(Box<dyn std::error::Error + Send + Sync>),

	/// An I/O error occurred on the connection.
	#[error(transparent)]
	IO(io::Error),

	/// The connection keep-alive timeout expired.
	#[error("The connection keep-alive timeout expired")]
	KeepAliveTimeout,
}

impl<TProtocol> Unpin for Connection<TProtocol> where TProtocol: ProtocolHandler {}

impl<TProtocol> Connection<TProtocol>
where
	TProtocol: ProtocolHandler,
{
	pub fn new(protocol: TProtocol, muxer: StreamMuxerBox) -> Self {
		let protocols = StreamProtocols(protocol.protocol_info().into_iter().collect());
		Connection {
			handler: protocol,
			muxer,
			protocols,
			futures_substream: Default::default(),
			negotiating_out: Default::default(),
			negotiating_in: Default::default(),
		}
	}

	/// Poll the substream of each protocol, and forward the event to them and vice versa.
	#[tracing::instrument(level = "debug", name = "Connection::poll_connection", skip(self, cx))]
	pub(crate) fn poll(&mut self, cx: &mut Context<'_>) -> Poll<Result<Event<TProtocol::ToProtocol>, ConnectionError>> {
		loop {
			// 1st check for timeout on newly asked substream
			match self.futures_substream.poll_next_unpin(cx) {
				Poll::Ready(Some(Ok(()))) => continue,
				Poll::Ready(Some(Err(_e))) => {
					// TODO file a dial error
				}
				Poll::Ready(None) | Poll::Pending => {}
			}

			// 2nd check what is new on the handler side
			match self.handler.poll(cx) {
				Poll::Pending => {}
				Poll::Ready(event) => match event {
					crate::ProtocolHandlerEvent::OutboundSubstreamRequest => {
						tracing::info!("asked for a new substream");
						// TODO: make this configurable
						self.futures_substream
							.push(FutureSubstream::new(Duration::from_secs(10)));
					}
					crate::ProtocolHandlerEvent::NotifyProtocol(e) => {
						return Poll::Ready(Ok(Event::Handler(e)));
					}
				},
			}

			match self.negotiating_out.poll_next_unpin(cx) {
				Poll::Ready(Some(Ok(io))) => {
					tracing::info!("negotiation outbound completed");
					self.handler.on_connection_event(ConnectionEvent::NewOutboundStream(io));
					continue;
				}
				Poll::Ready(Some(Err(e))) => {
					self.handler.on_connection_event(ConnectionEvent::FailNegotiation(e));
					continue;
				}
				Poll::Ready(None) | Poll::Pending => {}
			}

			match self.negotiating_in.poll_next_unpin(cx) {
				Poll::Ready(Some(Ok(io))) => {
					tracing::info!("negotiation inbound completed");
					self.handler.on_connection_event(ConnectionEvent::NewInboundStream(io));

					continue;
				}
				Poll::Ready(Some(Err(e))) => {
					self.handler.on_connection_event(ConnectionEvent::FailNegotiation(e));
					continue;
				}
				Poll::Ready(None) | Poll::Pending => {}
			}

			// 2nd we check for new events on the muxer side
			match self.muxer.poll_unpin(cx).map_err(ConnectionError::MuxerError)? {
				Poll::Pending => {}
				Poll::Ready(StreamMuxerEvent::AddressChange(new_address)) => {
					// TODO: fire a conneciton event
					tracing::info!("Address change event received");
					return Poll::Ready(Ok(Event::AddressChange(new_address)));
				}
			}

			// 3rd we check for new events on the muxer side
			match self.muxer.poll_unpin(cx).map_err(ConnectionError::MuxerError)? {
				Poll::Pending => {}
				Poll::Ready(StreamMuxerEvent::AddressChange(new_address)) => {
					// TODO: fire a conneciton event
					self.handler
						.on_connection_event(ConnectionEvent::AddressChange(new_address.clone()));
					return Poll::Ready(Ok(Event::AddressChange(new_address)));
				}
			}

			// 4th we check if we can open one of the newly asked substream
			if let Some(fut) = self.futures_substream.iter_mut().next() {
				match self
					.muxer
					.poll_outbound_unpin(cx)
					.map_err(ConnectionError::MuxerError)?
				{
					Poll::Pending => {}
					Poll::Ready(stream) => {
						fut.done();
						// need to start negotiating the protocol
						tracing::info!("Opening outbound negotiation substream {} ", self.negotiating_out.len());
						self.negotiating_out
							.push(OutboundStream::new(self.protocols.clone(), Box::new(stream)));
						continue;
					}
				}
			}

			// 5th we check if we can accept one of the newly asked substream
			match self.muxer.poll_inbound_unpin(cx).map_err(ConnectionError::MuxerError)? {
				Poll::Pending => {}
				Poll::Ready(stream) => {
					// need to start negotiating the protocol
					tracing::info!("Opening inbound negotiation substream {}", self.negotiating_in.len());
					self.negotiating_in
						.push(InboundStream::new(self.protocols.clone(), Box::new(stream)));
					continue;
				}
			}

			return Poll::Pending;
		}
	}

	pub(crate) fn on_protocol_event(&mut self, event: TProtocol::FromProtocol) {
		self.handler.on_protocol_event(event);
	}

	pub(crate) fn close(
		self,
	) -> (
		impl futures::Stream<Item = TProtocol::ToProtocol>,
		impl Future<Output = io::Result<()>>,
	) {
		let Connection {
			handler: mut protocol,
			muxer,
			..
		} = self;
		(stream::poll_fn(move |cx| protocol.poll_close(cx)), muxer.close())
	}
}
