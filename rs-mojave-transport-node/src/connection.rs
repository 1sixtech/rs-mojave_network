mod connection_id;

use std::{
	io,
	task::{Context, Poll},
};

pub use connection_id::*;
use futures::{FutureExt, StreamExt, future::BoxFuture, stream, stream::FuturesUnordered};
use multiaddr::Multiaddr;
use rs_mojave_network_core::{muxing::StreamMuxerBox, muxing::StreamMuxerExt};

use crate::{PeerProtocolBis, protocol};

pub struct Connection<TProtocol> {
	protocol: TProtocol,

	muxer: StreamMuxerBox,
}

/// Event generated by a [`Connection`].
#[derive(Debug, Clone)]
pub(crate) enum Event<T> {
	/// Event generated by the [`ConnectionHandler`].
	Handler(T),
	/// Address of the remote has changed.
	AddressChange(Multiaddr),
}

/// Errors that can occur in the context of an established `Connection`.
#[derive(Debug, thiserror::Error)]
pub enum ConnectionError {
	/// An I/O error occurred on the connection.
	// TODO: Eventually this should also be a custom error?
	#[error(transparent)]
	TransportError(Box<dyn std::error::Error + Send + Sync>),

	/// An I/O error occurred on the connection.
	#[error(transparent)]
	IO(io::Error),

	/// The connection keep-alive timeout expired.
	#[error("The connection keep-alive timeout expired")]
	KeepAliveTimeout,
}

impl<TProtocol> Unpin for Connection<TProtocol> where TProtocol: PeerProtocolBis {}

impl<TProtocol> Connection<TProtocol>
where
	TProtocol: PeerProtocolBis,
{
	pub fn new(protocol: TProtocol, muxer: StreamMuxerBox) -> Self {
		Connection { protocol, muxer }
	}

	/// Poll the substream of each protocol, and forward the event to them and vice versa.
	#[tracing::instrument(level = "debug", name = "Connection::poll_connection", skip(self, cx))]
	pub(crate) fn poll(&mut self, cx: &mut Context<'_>) -> Poll<Result<Event<TProtocol::ToProtocol>, ConnectionError>> {
		todo!()
	}

	pub(crate) fn on_protocol_event(&mut self, event: TProtocol::FromProtocol) {
		self.protocol.on_protocol_event(event);
	}

	pub(crate) fn close(
		self,
	) -> (
		impl futures::Stream<Item = TProtocol::ToProtocol>,
		impl Future<Output = io::Result<()>>,
	) {
		let Connection {
			mut protocol, muxer, ..
		} = self;
		(stream::poll_fn(move |cx| protocol.poll_close(cx)), muxer.close())
	}
}
